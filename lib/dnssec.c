/*  Copyright (C) 2015 CZ.NIC, z.s.p.o. <knot-dns@labs.nic.cz>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <assert.h>
#include <dnssec/binary.h>
#include <dnssec/crypto.h>
#include <dnssec/error.h>
#include <dnssec/key.h>
#include <dnssec/sign.h>
#include <libknot/descriptor.h>
#include <libknot/packet/rrset-wire.h>
#include <libknot/packet/wire.h>
#include <libknot/rdataset.h>
#include <libknot/rrset.h>
#include <libknot/rrtype/dnskey.h>
#include <libknot/rrtype/nsec.h>
#include <libknot/rrtype/rrsig.h>


#include "lib/defines.h"
#include "lib/dnssec/rrtype/ds.h"
#include "lib/dnssec.h"

#define DEBUG_MSG(fmt...) fprintf(stderr, fmt)

void kr_crypto_init(void)
{
	dnssec_crypto_init();
}

void kr_crypto_cleanup(void)
{
	dnssec_crypto_cleanup();
}

void kr_crypto_reinit(void)
{
	dnssec_crypto_reinit();
}

/* RFC4035 5.2, bullet 2 */
static int authenticate_referral(const dnssec_key_t *key, const knot_rrset_t *ds)
{
	assert(key && ds);
	assert(ds->type == KNOT_RRTYPE_DS);

	int ret = 0;
	dnssec_binary_t orig_ds_rdata;
	dnssec_binary_t generated_ds_rdata = {0, };

	{
		/* Obtain RDATA of the supplied DS. */
		const knot_rdata_t *rr = knot_rdataset_at(&ds->rrs, 0);
		orig_ds_rdata.size = knot_rdata_rdlen(rr);
		orig_ds_rdata.data = knot_rdata_data(rr);
	}

	/* Compute DS RDATA from the DNSKEY. */
	ret = dnssec_key_create_ds(key, _knot_ds_dtype(&ds->rrs, 0), &generated_ds_rdata);
	if (ret != DNSSEC_EOK) {
		ret = kr_error(ENOMEM);
		goto fail;
	}

	/* DS records contain algorithm, key tag and the digest.
	 * Therefore the comparison of the two DS is sufficient.
	 */
	ret = ((orig_ds_rdata.size == generated_ds_rdata.size) &&
	    (memcmp(orig_ds_rdata.data, generated_ds_rdata.data, orig_ds_rdata.size) == 0)) ? kr_ok() : kr_error(KNOT_DNSSEC_ENOKEY);

fail:
	dnssec_binary_free(&generated_ds_rdata);
	return ret;
}

#define FLG_WILDCARD_EXPANSION 0x01 /**< Possibly generated by using wildcard expansion. */

/**
 * Check the RRSIG RR validity according to RFC4035 5.3.1 .
 * @param flags     The flags are going to be set according to validation result.
 * @param covered   RRSet to be checked.
 * @param rrsigs    RRSet containing the signatures.
 * @param sig_pos   Specifies the signature within the RRSIG RRSet.
 * @param keys      Associated DNSKEY RRSet.
 * @param key_pos   Specifies the key within the DNSKEY RRSet,
 * @param key       Parsed key (converted for direct usage).
 * @param zone_name The name of the zone cut.
 * @param timestamp Validation time.
 */
static int validate_rrsig_rr(int *flags, const knot_rrset_t *covered,
                             const knot_rrset_t *rrsigs, size_t sig_pos,
                             const knot_rrset_t *keys, size_t key_pos, const dnssec_key_t *key,
                             const knot_dname_t *zone_name, uint32_t timestamp)
{
	if (!flags || !covered || !rrsigs || !keys || !key || !zone_name) {
		return kr_error(EINVAL);
	}
#warning TODO: Make the comparison case-insensitive.
	/* bullet 1 */
	if ((covered->rclass != rrsigs->rclass) || (knot_dname_cmp(covered->owner, rrsigs->owner) != 0)) {
		return kr_error(EINVAL);
	}
	/* bullet 2 */
	const knot_dname_t *signer_name = knot_rrsig_signer_name(&rrsigs->rrs, sig_pos);
	if (signer_name == NULL) {
		return kr_error(EINVAL);
	}
	if (knot_dname_cmp(signer_name, zone_name) != 0) {
		return kr_error(EINVAL);
	}
	/* bullet 3 */
	uint16_t tcovered = knot_rrsig_type_covered(&rrsigs->rrs, sig_pos);
	if (tcovered != covered->type) {
		return kr_error(EINVAL);
	}
	/* bullet 4 */
	if (knot_rrsig_labels(&rrsigs->rrs, sig_pos) > knot_dname_labels(covered->owner, NULL)) {
		return kr_error(EINVAL);
	}
	if (knot_rrsig_labels(&rrsigs->rrs, sig_pos) < knot_dname_labels(covered->owner, NULL)) {
		*flags |= FLG_WILDCARD_EXPANSION;
	}
	/* bullet 5 */
	if (knot_rrsig_sig_expiration(&rrsigs->rrs, sig_pos) < timestamp) {
		return kr_error(EINVAL);
	}
	/* bullet 6 */
	if (knot_rrsig_sig_inception(&rrsigs->rrs, sig_pos) > timestamp) {
		return kr_error(EINVAL);
	}
	/* bullet 7 */
	if ((knot_dname_cmp(keys->owner, signer_name) != 0) ||
	    (knot_dnskey_alg(&keys->rrs, key_pos) != knot_rrsig_algorithm(&rrsigs->rrs, sig_pos)) ||
	    (dnssec_key_get_keytag(key) != knot_rrsig_key_tag(&rrsigs->rrs, sig_pos))) {
		return kr_error(EINVAL);
	}
	/* bullet 8 */
	/* Checked somewhere else. */
	/* bullet 9 and 10 */
	/* One of the requirements should be always fulfilled. */

	return kr_ok();
}

/*!
 * \brief Add RRSIG RDATA without signature to signing context.
 *
 * Requires signer name in RDATA in canonical form.
 *
 * \param ctx   Signing context.
 * \param rdata Pointer to RRSIG RDATA.
 *
 * \return Error code, KNOT_EOK if successful.
 */
#define RRSIG_RDATA_SIGNER_OFFSET 18
static int sign_ctx_add_self(dnssec_sign_ctx_t *ctx, const uint8_t *rdata)
{
	assert(ctx);
	assert(rdata);

	int result;

	// static header

	dnssec_binary_t header = { 0 };
	header.data = (uint8_t *)rdata;
	header.size = RRSIG_RDATA_SIGNER_OFFSET;

	result = dnssec_sign_add(ctx, &header);
	if (result != DNSSEC_EOK) {
		return result;
	}

	// signer name

	const uint8_t *rdata_signer = rdata + RRSIG_RDATA_SIGNER_OFFSET;
	dnssec_binary_t signer = { 0 };
	signer.data = knot_dname_copy(rdata_signer, NULL);
	signer.size = knot_dname_size(signer.data);

	result = dnssec_sign_add(ctx, &signer);
	free(signer.data);

	return result;
}
#undef RRSIG_RDATA_SIGNER_OFFSET

/*!
 * \brief Add covered RRs to signing context.
 *
 * Requires all DNAMEs in canonical form and all RRs ordered canonically.
 *
 * \param ctx      Signing context.
 * \param covered  Covered RRs.
 *
 * \return Error code, KNOT_EOK if successful.
 */
static int sign_ctx_add_records(dnssec_sign_ctx_t *ctx, const knot_rrset_t *covered,
                                int trim_labels)
{
	// huge block of rrsets can be optionally created
	uint8_t *rrwf = malloc(KNOT_WIRE_MAX_PKTSIZE);
	if (!rrwf) {
		return KNOT_ENOMEM;
	}

	int written = knot_rrset_to_wire(covered, rrwf, KNOT_WIRE_MAX_PKTSIZE, NULL);
	if (written < 0) {
		free(rrwf);
		return written;
	}

	/* RFC4035 5.3.2
	 * Remove leftmost labels and replace them with '*.'.
	 */
	uint8_t *owner = rrwf;
	if (trim_labels > 0) {
		/**/
		for (int i = 0; i < trim_labels; ++i) {
			owner = (uint8_t *) knot_wire_next_label(owner, NULL);
		}
		*(--owner) = '*';
		*(--owner) = 1;
	}

	dnssec_binary_t rrset_wire = { 0 };
	rrset_wire.size = written - (owner - rrwf);
	rrset_wire.data = owner;
	int result = dnssec_sign_add(ctx, &rrset_wire);
	free(rrwf);

	return result;
}

/*!
 * \brief Add all data covered by signature into signing context.
 *
 * RFC 4034: The signature covers RRSIG RDATA field (excluding the signature)
 * and all matching RR records, which are ordered canonically.
 *
 * Requires all DNAMEs in canonical form and all RRs ordered canonically.
 *
 * \param ctx          Signing context.
 * \param rrsig_rdata  RRSIG RDATA with populated fields except signature.
 * \param covered      Covered RRs.
 *
 * \return Error code, KNOT_EOK if successful.
 */
/* TODO -- Taken from knot/src/knot/dnssec/rrset-sign.c. Re-write for better fit needed. */
static int sign_ctx_add_data(dnssec_sign_ctx_t *ctx, const uint8_t *rrsig_rdata,
                             const knot_rrset_t *covered, int trim_labels)
{
	int result = sign_ctx_add_self(ctx, rrsig_rdata);
	if (result != KNOT_EOK) {
		return result;
	}

	return sign_ctx_add_records(ctx, covered, trim_labels);
}

/* RFC4035 5.3.3 and 5.3.2 */
static int check_signature(const knot_rrset_t *rrsigs, size_t pos, const dnssec_key_t *key,
                           const knot_rrset_t *covered, int trim_labels)
{
	if (!rrsigs || !key || !dnssec_key_can_verify(key)) {
		return kr_error(EINVAL);
	}

	int ret;
	dnssec_sign_ctx_t *sign_ctx = NULL;
	dnssec_binary_t signature = {0, };

	knot_rrsig_signature(&rrsigs->rrs, pos, &signature.data, &signature.size);
	if (!signature.data || !signature.size) {
		ret = kr_error(EINVAL);
		goto fail;
	}

	ret = dnssec_sign_new(&sign_ctx, key);
	if (ret != DNSSEC_EOK) {
		ret = kr_error(ENOMEM);
		goto fail;
	}

	const knot_rdata_t *rr_data = knot_rdataset_at(&rrsigs->rrs, pos);
	uint8_t *rdata = knot_rdata_data(rr_data);

	ret = sign_ctx_add_data(sign_ctx, rdata, covered, trim_labels);
	if (ret != KNOT_EOK) {
		ret = kr_error(ENOMEM);
		goto fail;
	}

	ret = dnssec_sign_verify(sign_ctx, &signature);
	if (ret != KNOT_EOK) {
#warning TODO: proper DNSSEC error codes needed
		ret = kr_error(ENOMEM);
		goto fail;
	}

	ret = kr_ok();

fail:
	dnssec_sign_free(sign_ctx);
	return ret;
}

/**
 * Returns the number of labels that have been added by wildcard expansion.
 * @param expanded Expanded wildcard.
 * @param rrsigs   RRSet containing the signatures.
 * @param sig_pos  Specifies the signature within the RRSIG RRSet.
 * @return         Number of added labels, -1 on error.
 */
static int wildcard_radix_len_diff(const knot_dname_t *expanded,
                                   const knot_rrset_t *rrsigs, size_t sig_pos)
{
	if (!expanded || !rrsigs) {
		return -1;
	}

	return knot_dname_labels(expanded, NULL) - knot_rrsig_labels(&rrsigs->rrs, sig_pos);
}

/* RFC4035 5.4, bullet 2 */
static int nsec_nomatch_validate(const knot_rrset_t *nsec, const knot_dname_t *name)
{
	const knot_dname_t *next = knot_nsec_next(&nsec->rrs);

	if ((knot_dname_cmp(nsec->owner, name) < 0) &&
	    (knot_dname_cmp(name, next) < 0)) {
		return kr_ok();
	} else {
		return 1;
	}

#warning TODO: Is an additional request for NSEC name or wildcard necessary?
}

/**
 * Validates the non-existence of closer/exact match.
 * @param pkt        Packet to be validated.
 * @param section_id Section to work with.
 * @param name       The name to be checked.
 * @return           0 or error code.
 */
static int closer_match_nonexistence_validate(const knot_pkt_t *pkt, knot_section_t section_id,
                                              const knot_dname_t *name)
{
	if (!pkt || !name) {
		return kr_error(EINVAL);
	}

	/* Signatures are checked elsewhere. */

	const knot_pktsection_t *sec = knot_pkt_section(pkt, section_id);
	if (!sec) {
		return kr_error(EINVAL);
	}
	for (unsigned i = 0; i < sec->count; ++i) {
		const knot_rrset_t *rrset = knot_pkt_rr(sec, i);
		if ((rrset->type != KNOT_RRTYPE_NSEC) &&
		    (rrset->type != KNOT_RRTYPE_NSEC3)) {
			continue;
		}
		if (rrset->type == KNOT_RRTYPE_NSEC) {
			if (nsec_nomatch_validate(rrset, name) == 0) {
				return kr_ok();
			}
		} else {
#warning TODO: NSEC3 currently not supported
			return kr_error(ENOSYS);
		}
	}

	return kr_error(EINVAL);
}

int kr_rrset_validate(const knot_pkt_t *pkt, knot_section_t section_id,
                      const knot_rrset_t *covered, const knot_rrset_t *keys,
                      const knot_dname_t *zone_name, uint32_t timestamp)
{
	if (!pkt || !covered || !keys || !zone_name) {
		return kr_error(EINVAL);
	}

	int ret = kr_error(KNOT_DNSSEC_ENOKEY);
	for (unsigned i = 0; i < keys->rrs.rr_count; ++i) {
		ret = kr_rrset_validate_with_key(pkt, section_id, covered, keys, i, NULL, zone_name, timestamp);
		if (ret == 0) {
			break;
		}
	}

	return ret;
}

int kr_rrset_validate_with_key(const knot_pkt_t *pkt, knot_section_t section_id,
                               const knot_rrset_t *covered, const knot_rrset_t *keys,
                               size_t key_pos, const struct dseckey *key,
                               const knot_dname_t *zone_name, uint32_t timestamp)
{
	int ret;
	int val_flgs;
	struct dseckey *created_key = NULL;
	int trim_labels;
	if (key == NULL) {
		const knot_rdata_t *krr = knot_rdataset_at(&keys->rrs, key_pos);
		ret = kr_dnssec_key_from_rdata(&created_key, krr, keys->owner);
		if (ret != 0) {
			return ret;
		}
		key = created_key;
	}

	ret = kr_error(KNOT_DNSSEC_ENOKEY);
	const knot_pktsection_t *sec = knot_pkt_section(pkt, section_id);
	for (unsigned i = 0; i < sec->count; ++i) {
		/* Try every RRSIG. */
		const knot_rrset_t *rrsig = knot_pkt_rr(sec, i);
		if (rrsig->type != KNOT_RRTYPE_RRSIG) {
			continue;
		}
		for (uint16_t j = 0; j < rrsig->rrs.rr_count; ++j) {
			val_flgs = 0;
			trim_labels = 0;
			if (validate_rrsig_rr(&val_flgs, covered, rrsig, j,
			                      keys, key_pos, (dnssec_key_t *) key,
			                      zone_name, timestamp) != 0) {
				continue;
			}
			if (val_flgs & FLG_WILDCARD_EXPANSION) {
				trim_labels = wildcard_radix_len_diff(covered->owner, rrsig, j);
				if (trim_labels < 0) {
					break;
				}
			}
			if (check_signature(rrsig, j, (dnssec_key_t *) key, covered, trim_labels) != 0) {
				continue;
			}
			if (val_flgs & FLG_WILDCARD_EXPANSION) {
				if (closer_match_nonexistence_validate(pkt, KNOT_AUTHORITY, covered->owner) != 0) {
					continue;
				}
			}
			ret = kr_ok();
			break;
		}
		if (ret == kr_ok()) {
			break;
		}
	}

	kr_dnssec_key_free(&created_key);
	return ret;
}

int kr_dnskeys_trusted(const knot_pkt_t *pkt, knot_section_t section_id, const knot_rrset_t *keys,
                       const knot_rrset_t *ta, const knot_dname_t *zone_name, uint32_t timestamp)
{
	if (!pkt || !keys || !ta) {
		return kr_error(EINVAL);
	}

	/* RFC4035 5.2, bullet 1
	 * The supplied DS record has been authenticated.
	 * It has been validated or is part of a configured trust anchor.
	 *
	 * This implementation actually ignores the SEP flag.
	 */

#warning TODO: there should be an error saying that there is no matching key
	int ret = kr_error(KNOT_DNSSEC_ENOKEY);
	for (uint16_t i = 0; i < keys->rrs.rr_count; ++i) {
		/* RFC4035 5.3.1, bullet 8 */ /* ZSK */
		if (!(knot_dnskey_flags(&keys->rrs, i) & 0x0100)) {
			continue;
		}
		const knot_rdata_t *krr = knot_rdataset_at(&keys->rrs, i);
		struct dseckey *key;
		if (kr_dnssec_key_from_rdata(&key, krr, keys->owner) != 0) {
			continue;
		}
		if (authenticate_referral((dnssec_key_t *) key, ta) != 0) {
			kr_dnssec_key_free(&key);
			continue;
		}
		if (kr_rrset_validate_with_key(pkt, section_id, keys, keys, i, key, zone_name, timestamp) != 0) {
			kr_dnssec_key_free(&key);
			continue;
		}
		kr_dnssec_key_free(&key);
		ret = kr_ok();
		break;
	}

	return ret;
}

int kr_dnssec_key_from_rdata(struct dseckey **key, const knot_rdata_t *krdata, const knot_dname_t *kown)
{
	assert(key);

	dnssec_key_t *new_key = NULL;
	dnssec_binary_t binary_key;
	int ret;

	ret = dnssec_key_new(&new_key);
	if (ret != DNSSEC_EOK) {
		return kr_error(ENOMEM);
	}

	binary_key.size = knot_rdata_rdlen(krdata);
	binary_key.data = knot_rdata_data(krdata);
	if (!binary_key.size || !binary_key.data) {
		dnssec_key_free(new_key);
		return kr_error(KNOT_DNSSEC_ENOKEY);
	}
	ret = dnssec_key_set_rdata(new_key, &binary_key);
	if (ret != DNSSEC_EOK) {
		dnssec_key_free(new_key);
		return kr_error(ENOMEM);
	}

	ret = dnssec_key_set_dname(new_key, kown);
	if (ret != DNSSEC_EOK) {
		dnssec_key_free(new_key);
		return kr_error(ENOMEM);
	}

	*key = (struct dseckey *) new_key;
	return kr_ok();
}

void kr_dnssec_key_free(struct dseckey **key)
{
	assert(key);

	dnssec_key_free((dnssec_key_t *) *key);
	*key = NULL;
}
